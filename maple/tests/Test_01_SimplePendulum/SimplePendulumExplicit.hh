/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * Copyright (c) 2025, Davide Stocco and Enrico Bertolazzi.                  *
 *                                                                           *
 * The Sandals project is distributed under the BSD 2-Clause License.        *
 *                                                                           *
 * Davide Stocco                                           Enrico Bertolazzi *
 * University of Trento                                 University of Trento *
 * e-mail: davide.stocco@unitn.it         e-mail: enrico.bertolazzi@unitn.it *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// C++ generated code for explicit system: SimplePendulumExplicit
// This file has been automatically generated by Sandals.
// DISCLAIMER: If you need to edit it, do it wisely!

#ifndef SANDALS_MAPLE_SIMPLEPENDULUMEXPLICIT_EXPLICIT_HH
#define SANDALS_MAPLE_SIMPLEPENDULUMEXPLICIT_EXPLICIT_HH

using namespace Sandals;
using namespace std;

// No class description provided.
class SimplePendulumExplicit : public Explicit<2, 0>
{
  // User data
  Real m_g{9.81};
  Real m_l{1.0};

public:
  using VectorF  = typename Explicit<2, 2>::VectorF;
  using MatrixJF = typename Explicit<2, 2>::MatrixJF;
  using VectorH  = typename Explicit<2, 2>::VectorH;
  using MatrixJH = typename Explicit<2, 2>::MatrixJH;

  // Class constructor.
  SimplePendulumExplicit() : Explicit<2, 0>("SimplePendulumExplicit") {}

  // Class constructor.
  SimplePendulumExplicit(Real g, Real l)
    : Explicit<2, 0>("SimplePendulumExplicit"), m_g(g), m_l(l) {}

  // Evaluate the function f.
  VectorF f(VectorF const &in_1, Real t) const override
  {
    // Create properties' aliases
    using g = this->m_g;
    using l = this->m_l;

    // Create inputs' aliases
    using omega = in_0(0);
    using theta = in_0(1);

    // Evaluate function
    Real out_0 = -g / l * theta;
    Real out_1 = omega;

    // Store outputs
    VectorF out_f;
    out_f <<
      out_0, out_1;
    return out_f;
  }

  // Evaluate the Jacobian of f with respect to x.
  MatrixJF Jb_x(VectorF const &in_1, Real t) const override
  {
    // Create properties' aliases
    using g = this->m_g;
    using l = this->m_l;

    // Create inputs' aliases
    using omega = in_0(0);
    using theta = in_0(1);

    // Evaluate function
    Real out_0_0 = 0;
    Real out_0_1 = 1;
    Real out_1_0 = -g / l;
    Real out_1_1 = 0;

    // Store outputs
    MatrixJF out_Jb_x;
    out_Jb_x <<
      out_0_0, out_0_1, out_1_0, out_1_1;
    return out_Jb_x;
  }

  // Calculate the vector h of the invariants.
  VectorH h(VectorF const &in_1, Real t) const override
  {
    // Create properties' aliases
    using g = this->m_g;
    using l = this->m_l;

    // Create inputs' aliases
    using omega = in_0(0);
    using theta = in_0(1);

    // Evaluate function
    // No body

    // Store outputs
    VectorH out_h;
    out_h.setZero();
    return out_h;
  }

  // Calculate the Jacobian of h with respect to x.
  MatrixJH Jh_x(VectorF const &in_1, Real t) const override
  {
    // Create properties' aliases
    using g = this->m_g;
    using l = this->m_l;

    // Create inputs' aliases
    using omega = in_0(0);
    using theta = in_0(1);

    // Evaluate function
    // No body

    // Store outputs
    MatrixJH out_Jh_x;
    out_Jh_x.setZero();
    return out_Jh_x;
  }

  bool in_domain(VectorF const &/*x*/, Real /*t*/) const override {return true;}

} // class SimplePendulumExplicit

#endif // SANDALS_MAPLE_SIMPLEPENDULUMEXPLICIT_EXPLICIT_HH
